import streamlit as st
from PIL import Image
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt
import math
from io import BytesIO
import json
import cv2
import tempfile


## Functions ##

def fill_data_gaps(data, max_consecutive_gaps=3):
        # Iterate over each column in the DataFrame
        for column in data.columns:
            # Check if the column contains numerical data
            if pd.api.types.is_numeric_dtype(data[column]):
                # Check for gaps in the data column
                mask = data[column].isnull()
                consecutive_gaps = mask.astype(int).groupby(mask.ne(mask.shift()).cumsum()).cumsum()

                # Check if there are more than four consecutive gaps
                if consecutive_gaps.max() > max_consecutive_gaps:
                    # Create a simple Tkinter GUI to display the error message
                    st.error(f"Gap check 1: Error! More than {max_consecutive_gaps} consecutive gaps detected in column {column}. Unable to fill. Please go back to Kinovea/Tracker and track the missing points for {column}")
                    st.subheader("Ignore any error messages below. Refresh this page and try again once you have fixed the issue described in 'Gap check 1' above.")                          
                    st.stop()
                # Apply linear interpolation to fill gaps up to three rows in sequence
                data[column] = data[column].interpolate(method='linear', limit_area='inside')
                
        st.success('Gap check 1: Success! Less than 4 consecutive gaps in your data')
                
def dot_product_angle(df, i, ref_x, ref_y, point1_x, point1_y, point2_x, point2_y):
    v1_x = df.loc[i,point1_x] - df.loc[i,ref_x]
    v2_x = df.loc[i,point2_x] - df.loc[i,ref_x]
    v1_y = df.loc[i,point1_y] - df.loc[i,ref_y]
    v2_y = df.loc[i,point2_y] - df.loc[i,ref_y]
    
    joint_cos = (v1_x*v2_x + v1_y*v2_y)/(math.sqrt(v1_x**2+v1_y**2)*math.sqrt(v2_x**2+v2_y**2))
    
    joint_angle = math.acos(joint_cos)
    joint_angle_degrees = math.degrees(joint_angle)
    
    return joint_angle_degrees
        
def apply_low_pass_filter(data, cutoff_freq, fs):
    # Calculate the filter coefficients
    nyquist = 0.5 * fs
    normal_cutoff = cutoff_freq / nyquist
    b, a = butter(4, normal_cutoff, btype='low', analog=False)
    
    # Apply the filter to the data
    filtered_data = filtfilt(b, a, data)
    
    return filtered_data


## Main script

image = Image.open('test_image.png')
st.image(image,width=800)
st.title('Data converter for A18FB Assessment 1')
st.caption('This web app was designed to convert, smooth, and export data obtained on Factorial Biomechanics.')

st.subheader('What does this web app do?')
st.text('1. It smoothes your data to minimise the noise in your joint and centre of mass (CoM) coordinates and joint angles.')
st.text('2. It calculates the net force acting on the body based on the CoM information.')
st.text('3. It exports selected output data (smoothed coordinates, joint angles, and net force) as an Excel file.')

st.text('')
st.subheader('Before you start, make sure you have:')
st.text('1. calibrated and digitised your video data on the Factorial Biomechanics page;')
st.text('2. sense-checked your data (e.g. was the calibration data succesfully applied?)')
st.text('3. downloaded your data as json file (not only video file)')


st.subheader("Input participant's information and upload your json file")

with st.form(key='mass_form'):
    
    entered_fps = st.number_input("Frame rate of your video data (frames per second).")
    entered_mass = st.number_input("Participant's body mass (kg).")
           
    submit1 = st.form_submit_button("Confirm the frame rate and participant's mass")
    
    if submit1:
        st.text(f'Frame Rate: {entered_fps} frames per second')
        st.text(f'Body mass: {entered_mass} kg')


uploaded_video = st.file_uploader('upload the video generated by Factorial Biomechanics', type='mp4',accept_multiple_files=False, key ='mp4')       
uploaded_file = st.file_uploader('Upload your json file generated by Factorial Biomechanics', type='json', accept_multiple_files=False, key ='json')

    
if entered_mass == 0:
    st.error("Input participant's mass (don't forget to click the confirm button)")         
    st.stop()
    
elif uploaded_file is None:
    st.error('Upload your json file')         
    st.stop()

elif uploaded_video is None:
    st.error('Upload your tracked video file')         
    st.stop()


progress_placeholder = st.empty()
        
if uploaded_file:
    
    raw_data = uploaded_file.getvalue()
        
    data = json.loads(raw_data.decode("utf-8"))

    if uploaded_video is not None:
        # Save the uploaded video to a temporary file
        with tempfile.NamedTemporaryFile(delete=False, suffix=".mp4") as temp_file:
            temp_file.write(uploaded_video.read())
            temp_video_path = temp_file.name

    # Use OpenCV to read the video file
    video = cv2.VideoCapture(temp_video_path)

    if not video.isOpened():
        st.error("Error: Could not open the uploaded video.")
    else:
        # Get the total number of frames
        total_frames = int(video.get(cv2.CAP_PROP_FRAME_COUNT))
        st.success(f"Total number of frames in the video: {total_frames}")
 
    frames = len(data)

    linear_df_raw = pd.DataFrame(index=range(frames), columns=range(69))
    angular_df_raw = pd.DataFrame(index=range(frames), columns=range(11))
    diff = total_frames/frames
    fps = entered_fps/diff


    for i in range(frames):
        
        for j in range(len(data[i]['keypoints2D'])):
            segment = data[i]['keypoints2D'][j]['name']
            
            if i == 0:
                linear_df_raw = linear_df_raw.rename(columns={j*2+1: segment+'_X (m)'})
                linear_df_raw = linear_df_raw.rename(columns={j*2+2: segment+'_Y (m)'})
                
            linear_df_raw.iloc[i,j*2+1] = data[i]['keypoints2D'][j]['realX']
            linear_df_raw.iloc[i,j*2+2] = data[i]['keypoints2D'][j]['realY']
            
        linear_df_raw.iloc[i,67] = data[i]['com2D']['realX']
        linear_df_raw.iloc[i,68] = data[i]['com2D']['realY']
        
        for k,joint in enumerate(data[i]['angles2D']):
            if i == 0:
                angular_df_raw = angular_df_raw.rename(columns={k+1: joint})
        
        angular_df_raw.loc[i,'rightElbowAngle'] = dot_product_angle(linear_df_raw,i,'right_elbow_X (m)','right_elbow_Y (m)',
                                            'right_wrist_X (m)','right_wrist_Y (m)','right_shoulder_X (m)','right_shoulder_Y (m)')
        
        angular_df_raw.loc[i,'leftElbowAngle'] = dot_product_angle(linear_df_raw,i,'left_elbow_X (m)','left_elbow_Y (m)',
                                            'left_wrist_X (m)','left_wrist_Y (m)','left_shoulder_X (m)','left_shoulder_Y (m)')
            
        angular_df_raw.loc[i,'rightKneeAngle'] = dot_product_angle(linear_df_raw,i,'right_knee_X (m)','right_knee_Y (m)',
                                            'right_ankle_X (m)','right_ankle_Y (m)','right_hip_X (m)','right_hip_Y (m)')
        
        angular_df_raw.loc[i,'leftKneeAngle'] = dot_product_angle(linear_df_raw,i,'left_knee_X (m)','left_knee_Y (m)',
                                            'left_ankle_X (m)','left_ankle_Y (m)','left_hip_X (m)','left_hip_Y (m)')
        
        angular_df_raw.loc[i,'rightShoulderAngle'] = dot_product_angle(linear_df_raw,i,'right_shoulder_X (m)','right_shoulder_Y (m)',
                                            'right_hip_X (m)','right_hip_Y (m)','right_elbow_X (m)','right_elbow_Y (m)')
        
        angular_df_raw.loc[i,'leftShoulderAngle'] = dot_product_angle(linear_df_raw,i,'left_shoulder_X (m)','left_shoulder_Y (m)',
                                            'left_hip_X (m)','left_hip_Y (m)','left_elbow_X (m)','left_elbow_Y (m)')
        
        angular_df_raw.loc[i,'rightHipAngle'] = dot_product_angle(linear_df_raw,i,'right_hip_X (m)','right_hip_Y (m)',
                                            'right_shoulder_X (m)','right_shoulder_Y (m)','right_knee_X (m)','right_knee_Y (m)')
        
        angular_df_raw.loc[i,'leftHipAngle'] = dot_product_angle(linear_df_raw,i,'left_hip_X (m)','left_hip_Y (m)',
                                            'left_shoulder_X (m)','left_shoulder_Y (m)','left_knee_X (m)','left_knee_Y (m)')
        
        angular_df_raw.loc[i,'rightAnkleAngle'] = dot_product_angle(linear_df_raw,i,'right_ankle_X (m)','right_ankle_Y (m)',
                                            'right_knee_X (m)','right_knee_Y (m)','right_foot_index_X (m)','right_foot_index_Y (m)')
        
        angular_df_raw.loc[i,'leftAnkleAngle'] = dot_product_angle(linear_df_raw,i,'left_ankle_X (m)','left_ankle_Y (m)',
                                            'left_knee_X (m)','left_knee_Y (m)','left_foot_index_X (m)','left_foot_index_Y (m)')
        
        
        if i == 0:       
            linear_df_raw.iloc[i,0] = 0
            angular_df_raw.iloc[i,0] = 0
        else:
            linear_df_raw.iloc[i,0] = linear_df_raw.iloc[i-1,0]+1/fps
            angular_df_raw.iloc[i,0] = angular_df_raw.iloc[i-1,0]+1/fps
            
    linear_df_raw = linear_df_raw.rename(columns={0: 'Time (s)'})
    angular_df_raw = angular_df_raw.rename(columns={0: 'Time (s)'})
    linear_df_raw = linear_df_raw.rename(columns={67: 'CoM_X (m)'})
    linear_df_raw = linear_df_raw.rename(columns={68: 'CoM_Y (m)'})

 
    linear_df_raw.iloc[:,1:] = linear_df_raw.iloc[:,1:]*-1

    ref_X = linear_df_raw.iloc[0,61]
    ref_Y = linear_df_raw.iloc[0,62]

    for col in linear_df_raw.columns:
        if '_X' in col:
            linear_df_raw[col] = linear_df_raw[col]-ref_X
            
        elif '_Y' in col:
            linear_df_raw[col] = linear_df_raw[col]-ref_Y

    # linear_df = linear_df.astype(int)
    # angular_df = angular_df.astype(int)

    linear_df = linear_df_raw.copy()
    angular_df = angular_df_raw.copy()

    linear_cols = list(linear_df.columns[1:])
    angular_cols = list(angular_df.columns[1:])

    for linear_col in linear_cols:
        linear_df[linear_col] = apply_low_pass_filter(linear_df_raw[linear_col], 6,fps)

    for angular_col in angular_cols:
        angular_df[angular_col] = apply_low_pass_filter(angular_df_raw[angular_col], 6,fps)

    com_wb_x = linear_df['CoM_X (m)']
    com_wb_y = linear_df['CoM_Y (m)']

    com_wb_x_v = com_wb_x.copy()
    com_wb_y_v = com_wb_y.copy()
    com_wb_x_a = com_wb_x.copy()
    com_wb_y_a = com_wb_y.copy()
    
    for i in range(len(com_wb_x)-2):
        
        com_wb_x_v.iloc[i+1] = (com_wb_x.iloc[i+2]-com_wb_x.iloc[i])/(linear_df['Time (s)'].iloc[i+2]-linear_df['Time (s)'].iloc[i])
        com_wb_y_v.iloc[i+1] = (com_wb_y.iloc[i+2]-com_wb_y.iloc[i])/(linear_df['Time (s)'].iloc[i+2]-linear_df['Time (s)'].iloc[i])

    com_wb_x_v.iloc[0] = (com_wb_x_v.iloc[1] + com_wb_x_v.iloc[2])-com_wb_x_v.iloc[3]
    com_wb_x_v.iloc[-1] = (com_wb_x_v.iloc[-2] + com_wb_x_v.iloc[-3])-com_wb_x_v.iloc[-4]

    com_wb_y_v.iloc[0] = (com_wb_y_v.iloc[1] + com_wb_y_v.iloc[2])-com_wb_y_v.iloc[3]
    com_wb_y_v.iloc[-1] = (com_wb_y_v.iloc[-2] + com_wb_y_v.iloc[-3])-com_wb_y_v.iloc[-4]


    for i in range(len(com_wb_x)-2):
        
        com_wb_x_a.iloc[i+1] = (com_wb_x_v.iloc[i+2]-com_wb_x_v.iloc[i])/(linear_df['Time (s)'].iloc[i+2]-linear_df['Time (s)'].iloc[i])
        com_wb_y_a.iloc[i+1] = (com_wb_y_v.iloc[i+2]-com_wb_y_v.iloc[i])/(linear_df['Time (s)'].iloc[i+2]-linear_df['Time (s)'].iloc[i])

    com_wb_x_a.iloc[0] = (com_wb_x_a.iloc[1] + com_wb_x_a.iloc[2])-com_wb_x_a.iloc[3]
    com_wb_x_a.iloc[-1] = (com_wb_x_a.iloc[-2] + com_wb_x_a.iloc[-3])-com_wb_x_a.iloc[-4]

    com_wb_y_a.iloc[0] = (com_wb_y_a.iloc[1] + com_wb_y_a.iloc[2])-com_wb_y_a.iloc[3]
    com_wb_y_a.iloc[-1] = (com_wb_y_a.iloc[-2] + com_wb_y_a.iloc[-3])-com_wb_y_a.iloc[-4]

    net_force_x = com_wb_x_a*entered_mass
    net_force_y = com_wb_y_a*entered_mass

    linear_df[' '] = pd.Series([None] * len(net_force_x ))
    linear_df['Net_Force_X (N)'] = net_force_x
    linear_df['Net_Force_Y (N)'] = net_force_y

            
    progress_placeholder.write("Processing data...")
    # Your existing code for data processing and calculations
    
    df_len = len(linear_df)

    df_int = math.floor(df_len/11)

    fig2, axs = plt.subplots(3, 4, figsize=(15, 10))

    LX = linear_df[['left_index_X (m)','left_wrist_X (m)','left_elbow_X (m)','left_shoulder_X (m)','left_hip_X (m)','left_knee_X (m)','left_ankle_X (m)','left_heel_X (m)','left_foot_index_X (m)']]
    LY = linear_df[['left_index_Y (m)','left_wrist_Y (m)','left_elbow_Y (m)','left_shoulder_Y (m)','left_hip_Y (m)','left_knee_Y (m)','left_ankle_Y (m)','left_heel_Y (m)','left_foot_index_Y (m)']]

    RX = linear_df[['right_index_X (m)','right_wrist_X (m)','right_elbow_X (m)','right_shoulder_X (m)','right_hip_X (m)','right_knee_X (m)','right_ankle_X (m)','right_heel_X (m)','right_foot_index_X (m)']]
    RY = linear_df[['right_index_Y (m)','right_wrist_Y (m)','right_elbow_Y (m)','right_shoulder_Y (m)','right_hip_Y (m)','right_knee_Y (m)','right_ankle_Y (m)','right_heel_Y (m)','right_foot_index_Y (m)']]

    ShoulderX = linear_df[['right_shoulder_X (m)','left_shoulder_X (m)']]
    ShoulderY = linear_df[['right_shoulder_Y (m)','left_shoulder_Y (m)']]

    HipX = linear_df[['right_hip_X (m)','left_hip_X (m)']]
    HipY = linear_df[['right_hip_Y (m)','left_hip_Y (m)']]

    xmin = (LX.min()-0.5).min()
    xmax = (LX.max()+0.5).max()

    ymin = (LY.min()-0.05).min()
    ymax = (LY.max()+0.6).max()

    for num, i in enumerate(range(0, df_len,df_int)):
        if 0 <= num <= 3:
            fig_row = 0
            fig_col = num

        elif 4 <= num <= 7:
            fig_row = 1
            fig_col = num-4

        elif 8 <= num <= 11:
            fig_row = 2
            fig_col = num-8


        fig_time = linear_df.iloc[i,0]
        fig_time = round(fig_time,2)

        axs[fig_row, fig_col].plot(LX.iloc[i],LY.iloc[i])
        axs[fig_row, fig_col].plot(RX.iloc[i],RY.iloc[i])
        axs[fig_row, fig_col].plot(ShoulderX.iloc[i],ShoulderY.iloc[i])
        axs[fig_row, fig_col].plot(HipX.iloc[i],HipY.iloc[i])

        axs[fig_row, fig_col].set_xlim(left=xmin, right=xmax)
        axs[fig_row, fig_col].set_ylim(bottom=ymin, top=ymax)
        axs[fig_row, fig_col].set_title(f'Time: {fig_time} s')
        axs[fig_row, fig_col].set_xticks([])
        
        CM_x = linear_df['CoM_X (m)'].iloc[i] 
        CM_y = linear_df['CoM_Y (m)'].iloc[i] 

        Head_x = (linear_df.loc[i,'left_ear_X (m)']+linear_df.loc[i,'right_ear_X (m)'])/2
        Head_y = (linear_df.loc[i,'left_ear_Y (m)']+linear_df.loc[i,'right_ear_Y (m)'])/2
        
        axs[fig_row, fig_col].scatter(CM_x, CM_y, color='red', marker='o')
        axs[fig_row, fig_col].scatter(Head_x, Head_y, marker='o', s=100)
        
        if i ==0 | i ==4 | i==8:
            axs[fig_row, fig_col].set_ylabel('Y Displacement (m)')
        else:
            axs[fig_row, fig_col].set_yticks([])
        
    st.pyplot(fig2)
    st.text('Stick figures of the processed jump movement (the red dots show the location of CoM)')

    linear_df.to_excel(buf := BytesIO(), index=False)
    
    # Display the download button after processing is complete
    st.success("Processing complete!")
    st.text('Does the series of stick figures look like a jump movement? If yes:')
    st.download_button(
        "Download your output file",
        buf.getvalue(),
        "outdat_data.xlsx",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    )
    st.text('If not, check and fix your tracking file on Factorial Biomechanics, and run the analysis again')
    
    progress_placeholder.empty()
        
            
        
        
